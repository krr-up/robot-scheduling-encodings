% ------------------------------------------------------------------------------
% Common code for sequencing tasks that have been assigned to robots. Note: this
% is now separate from the assignment code so that we can look at different
% sequencing mechanisms.
%
% For any robot with a task we want to enforce that there must be exactly one
% linear task sequence.
%
% Note: however, the following code by itself doesn't generate proper sequences
% and relies on the DL timing constraints (or some othere cyclicity detection)
% to enforce proper sequencing. In particular without the DL constraints we can
% have: 1) a robot with a one or more cyclic task_sequences (provided there is
% also a non-cyclic task sequence for that robot), 2) wait dependencies are not
% guaranteed to be satisfied (both for wait dependencies assigned to the same
% robot and for wait dependencies assigned between different robots).
%
% Input facts: robot/1, tasks/2, same_robot/2, assignment/2.
% Output facts: task_sequence/2
% ------------------------------------------------------------------------------

% ------------------------------------------------------------------------------
% Don't choose pickup-putdown sequences since they are completely determined by
% the pickup.  Make sure each robot with assignments has a linear task sequences
% are linear (see note above that there could still be a secondary cyclic task
% sequence).
% ------------------------------------------------------------------------------

0 { task_sequence(T,T') : depends(deliver,T',_) } 1 :- depends(deliver,_,T).
task_sequence(T,T')                                 :- depends(deliver,T,T').

:- task_sequence(T,T'),
   not same_robot(T,T'), not same_robot(T',T), not depends(deliver,T,T').

%:- task_sequence(T,T'), task_sequence(T',T).             % Stop trivial cycles


% Make sure a task can't have more than one predecessor. For git records here
% are three encodings documenting their size (in the number of independant tasks):
%
% - the original is naive and has qubic number of constraints
%
%    :- task_sequence(T',T), task_sequence(T'',T), T' < T''.
%
% - the second has one constraint but is quadratic (maybe qubic?) in size.
%
%    :- 1 #count{ T : task_sequence(T',T), task_sequence(T'',T), T' < T''}.
%
% - has linear number of constraints which are linear in size

:- task(T,_), 2 #count{ T' : task_sequence(T',T) }.

% Enforcing that each task is in a sequence is not needed - since each task is
% part of a pickup-putdown delivery and task_sequence generation enforces this.
%
%     :- task(T,_), not task_sequence(T,_), not task_sequence(_,T).


% Each assigned robot must have exactly one linear sequence; hence must have
% only a single first task. For git records here are options:
%
% - Each robot must have at most one linear sequence (with optional rule that
%   each assigned robot must have at least one linear sequence).
%
%   :- robot(R), #count{ T : assignment(R,T), not task_sequence(_,T) } > 1.
%   :- assignment(R,_), #count{ T : assignment(R,T), not task_sequence(_,T) } = 0.
%
% - Each assigned robot must have exactly one linear sequence
%

:- assignment(R,_), not #count{ T : assignment(R,T), not task_sequence(_,T) } = 1.


% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------
